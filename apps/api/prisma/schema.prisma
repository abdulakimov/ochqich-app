generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum DeviceStatus {
  ACTIVE
  REVOKED
}

enum ChallengeStatus {
  PENDING
  USED
  EXPIRED
}

enum SessionStatus {
  ACTIVE
  REVOKED
}

enum ConsentRequestStatus {
  PENDING
  APPROVED
  DENIED
  EXPIRED
}

enum AuditAction {
  LOGIN_OK
  LOGIN_FAIL
  DEVICE_ADD
  DEVICE_REVOKE
  OTP_START
  OTP_VERIFY_OK
  OTP_VERIFY_FAIL
  CONSENT_REQUEST_CREATE
  CONSENT_APPROVE
  CONSENT_DENY
  CONSENT_RESULT_FETCH
  CONSENT_WEBHOOK_SENT
  CONSENT_WEBHOOK_FAIL
  RECOVERY_CODE_GENERATE
  RECOVERY_CODE_USE_OK
  RECOVERY_CODE_USE_FAIL
  RECOVERY_OTP_START
  RECOVERY_OTP_VERIFY_OK
  RECOVERY_OTP_VERIFY_FAIL
  RECOVERY_RATE_LIMIT_HIT
}

enum OtpPurpose {
  AUTH
  RECOVERY
}

model User {
  id              String           @id @default(cuid())
  phone           String           @unique
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  devices         Device[]
  sessions        Session[]
  auditLogs       AuditLog[]
  consentRequests ConsentRequest[]
  recoveryCodes   RecoveryCode[]
}

model Provider {
  id              String           @id @default(cuid())
  name            String
  apiKey          String           @unique
  redirectUri     String
  webhookUrl      String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  consentRequests ConsentRequest[]
}

model OtpVerification {
  id         String     @id @default(cuid())
  phone      String
  otpHash    String
  purpose    OtpPurpose @default(AUTH)
  expiresAt  DateTime
  verifiedAt DateTime?
  createdAt  DateTime   @default(now())

  @@index([phone, purpose, expiresAt])
}

model RecoveryCode {
  id        String   @id @default(cuid())
  userId    String
  codeHash  String   @unique
  usedAt    DateTime?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, usedAt])
}

model Device {
  id           String          @id @default(cuid())
  userId       String
  fingerprint  String
  publicKey    String
  deviceName   String?
  status       DeviceStatus    @default(ACTIVE)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenges   AuthChallenge[]
  sessions     Session[]

  @@unique([userId, fingerprint])
  @@index([userId, status])
}

model AuthChallenge {
  id         String          @id @default(cuid())
  deviceId   String
  nonce      String
  expiresAt  DateTime
  status     ChallengeStatus @default(PENDING)
  createdAt  DateTime        @default(now())
  usedAt     DateTime?
  device     Device          @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@index([deviceId, status])
}

model Session {
  id               String        @id @default(cuid())
  userId           String
  deviceId         String
  refreshTokenHash String        @unique
  status           SessionStatus @default(ACTIVE)
  expiresAt        DateTime
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  revokedAt        DateTime?
  user             User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  device           Device        @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([deviceId, status])
}

model ConsentRequest {
  id                  String               @id @default(cuid())
  providerId          String
  userId              String?
  requestedAttributes String[]
  status              ConsentRequestStatus @default(PENDING)
  expiresAt           DateTime
  token               String               @unique
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  provider            Provider             @relation(fields: [providerId], references: [id], onDelete: Cascade)
  user                User?                @relation(fields: [userId], references: [id], onDelete: SetNull)
  decision            ConsentDecision?

  @@index([providerId, status])
  @@index([userId, status])
  @@index([expiresAt, status])
}

model ConsentDecision {
  id                String         @id @default(cuid())
  consentRequestId  String         @unique
  approvedAttributes String[]
  deniedAttributes  String[]
  decidedAt         DateTime
  consentRequest    ConsentRequest @relation(fields: [consentRequestId], references: [id], onDelete: Cascade)

  @@index([decidedAt])
}

model AuditLog {
  id         String      @id @default(cuid())
  userId     String?
  deviceId   String?
  action     AuditAction
  metadata   Json?
  createdAt  DateTime    @default(now())
  user       User?       @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, action])
  @@index([deviceId, action])
}
